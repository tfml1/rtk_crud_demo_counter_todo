import { createSlice, nanoid } from "@reduxjs/toolkit";
//looping through an array r providing keys in the array not considered good idea so usenano provided by rdx n we shall use it in such situations
const initialState = {
  todos: [
    /* id:0, text: "test todo"  */
  ]
};

export const todoSlice = createSlice({
  name: "todoprogramtest",
  initialState,
  reducers: {
    addtodo: (state, action) => {
      // state is the global state n action carries the payload, immrrunning in bg inside reducer block so no need for  ...state, spread operator creating shallow  copy like legesy redux
      // cant do state.id=... and state.text=... directly as each update of todo element in the todos array is an object that contains {id:"xxxx", text:"yyyy"} so first we create an obj todotemp then arr.push in a new object in the array, so create a const todotemp that creates a new obj frm action recived
      const todotemp = {
        id: nanoid(),
        text: action.payload
      };
      state.todos.push(todotemp);
    },

    deletetodo: (state, action) => {
      state.todos = state.todos.filter((iter) => {
        return iter.id !== action.payload;
      }); // filter takes in true n false n does not keep objs that are returned false, so on each !== compair, if iteration id diff frmpayload generated by onclick in TodoComponent , if both not equal, true returned on !==compair n that iteration value added by filter to the todos arrays , id it matches then not eql to compair becomes false n that iter obj not added to the recreated array, note, immer still running in bg inside reducers block
    }
  }
});

export const { addtodo, deletetodo } = todoSlice.actions;

export default todoSlice.reducer;
